<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>D3 Temp Chart Test</title>
	<style>

		body {
			font: 10px sans-serif;
		}

		.axis path,
		.axis line {
			fill: none;
			stroke: #666;
			shape-rendering: crispEdges;
		}

		.y.axis .tick line {
			/*display: none;*/
		}

		.x.axis path {
			/*display: none;*/
		}

		.line, .similarday {
			fill: none;
			stroke: steelblue;
			stroke-width: 1.5px;
			cursor: pointer;
		}
		.line:hover {
			stroke-width: 3px;
		}

		#chartContainer {
			background: #f3f3f3;
			overflow: hidden;
	    width:100%;
	    height:100%;
		}

	</style>
</head>
<body>
	<div id="chartContainer"></div>

	<script src="http://d3js.org/d3.v3.js"></script>
	<script>
		var padding = {top: 20, right: 20, bottom: 30, left: 50};
		var parseDateTime = d3.time.format("%Y%m%d").parse;
		var sourceData, sourceDays, xScale, yScale, line;
		var prevChartWidth = 0, prevChartHeight = 0;
  	var updateTransistionMS = 750; // milliseconds

  	// create svg and g to contain the chart contents
		var chartSvg = d3.select("#chartContainer").append("svg")
		.append("g")
		.attr("class", "chartContainer")
		.attr("transform", "translate(" + padding.left + "," + padding.top + ")");

		// create the x axis container
		chartSvg.append("g")
		.attr("class", "x axis");

		// create the y axis container
		chartSvg.append("g")
		.attr("class", "y axis");

		d3.tsv("data/data.tsv", function(error, data) {
			color = d3.scale.category10();

			color.domain(d3.keys(data[0]).filter(function(key) { return key !== "datetime"; }));

			data.forEach(function(d) {
				d.datetime = parseDateTime(d.datetime);
			});

			// set the global data variable
    	sourceData = data;

			var similardays = color.domain().map(function(name) {
				return {
					name: name,
					values: sourceData.map(function(d) {
						return {datetime: d.datetime, temperature: +d[name]};
					})
				};
			});

			sourceDays = similardays;

			xScale = d3.time.scale()
    	.domain(d3.extent(data, function(d) { return d.datetime; }));

			yScale = d3.time.scale()
    	.domain([
				d3.min(similardays, function(c) { return d3.min(c.values, function(v) { return v.temperature; }); }),
				d3.max(similardays, function(c) { return d3.max(c.values, function(v) { return v.temperature; }); })
			]);

			xAxis = d3.svg.axis()
			.scale(xScale)
			.orient("bottom");

			yAxis = d3.svg.axis()
			.scale(yScale)
			.orient("left");

			line = d3.svg.line()
			.x(function(d) { return xScale(d.datetime); })
			.y(function(d) { return yScale(d.temperature); })
			.interpolate("basis");

			updateChart(true);


			// svg.append("g")
			// .attr("class", "x axis")
			// .attr("transform", "translate(0," + height + ")")
			// .call(xAxis);

			// svg.append("g")
			// .attr("class", "y axis")
			// .call(yAxis)
			// .append("text")
			// .attr("transform", "rotate(-90)")
			// .attr("y", 6)
			// .attr("dy", ".71em")
			// .style("text-anchor", "end")
			// .text("Temperature");

			
		});

		// var x = d3.time.scale()
		// .range([0, width]);

		// var y = d3.scale.linear()
		// .range([height, 0]);

		// var color = d3.scale.category10();

		// var line = d3.chartSvg.line()
		// .interpolate("basis")
		// .x(function(d) { return x(d.datetime); })
		// .y(function(d) { return y(d.temperature); });

		// var svg = d3.select(".data-container").append("svg")
		// .attr("width", width + margin.left + margin.right)
		// .attr("height", height + margin.top + margin.bottom)
		// .append("g")
		// .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

		

		function updateChart(init) {
			// get the height and width subtracting the padding
			var chartWidth = document.getElementById('chartContainer')
			.getBoundingClientRect().width - padding.left - padding.right;

			var chartHeight = document.getElementById('chartContainer')
			.getBoundingClientRect().height - padding.top - padding.bottom;

			// only update if chart size has changed
	    if ((prevChartWidth != chartWidth) ||
	      (prevChartHeight != chartHeight))
	    {
	      prevChartWidth = chartWidth;
	      prevChartHeight = chartHeight;

	      //set the width and height of the SVG element
	      chartSvg.attr("width", chartWidth + padding.left + padding.right)
	      .attr("height", chartHeight + padding.top + padding.bottom);

	      // ranges are based on the width and height available so reset
	      xScale.range([0, chartWidth]);
	      yScale.range([chartHeight, 0]);

	      if (init)
	      {
	        // if first run then just display axis with no transition
	        chartSvg.select(".x")
	        .attr("transform", "translate(0," + chartHeight + ")")
	        .call(xAxis);

	        chartSvg.select(".y")
	        .call(yAxis);
	      }
	      else
	      {
	        // for subsequent updates use a transistion to animate the axis to the new position
	        var t = chartSvg.transition().duration(updateTransistionMS);

	        t.select(".x")
	        .attr("transform", "translate(0," + chartHeight + ")")
	        .call(xAxis); 

	        t.select(".y")
	        .call(yAxis);
	      }

	   //    var similarday = chartSvg.selectAll(".similarday")
				// .data(sourceDays)
				// .enter().append("g")
				// .attr("class", "similarday");

				// bind up the data to the line
	      var similarday = chartSvg.selectAll(".similarday")
	      .data(sourceDays); // needs to be an array (size of 1 for our data) of arrays
				

				// similarday.append("text")
				// .datum(function(d) { return {name: d.name, value: d.values[d.values.length - 1]}; })
				// .attr("transform", function(d) { return "translate(" + xScale(d.value.datetime) + "," + yScale(d.value.temperature) + ")"; })
				// .attr("x", 3)
				// .attr("dy", ".35em")
				// .text(function(d) { return d.name; });

				similarday.transition()
	      .duration(updateTransistionMS)
	      .attr("d", function(d) { 
					return line(d.values); 
				});

	      // add line if not already existing
		    similarday.enter().append("path")
		    .attr("class", "similarday")
		    .attr("d", function(d) { 
				return line(d.values); 
			})
			.style("stroke", function(d) { return color(d.name); });

	   //    // add line if not already existing
	   //    similarday.append("path")
				// .attr("class", "line")
				// .attr("d", function(d) { 
				// 	return line(d.values); 
				// })
				// .style("stroke", function(d) { return color(d.name); });

	      // bind up the data to the line
	      // var lines = chartSvg.selectAll(".line")
	      // .data([sourceData]); // needs to be an array (size of 1 for our data) of arrays

	      // // transistion to new position if already exists
	      // lines.transition()
	      // .duration(updateTransistionMS)
	      // .attr("d", line);

	      // // add line if not already existing
	      // lines.enter().append("path")
	      // .attr("class", "line")
	      // .attr("d", line);
	    }
		}

		// look for resize but use timer to only call the update script when a resize stops
		var resizeTimer;
		window.onresize = function(event) {
		  clearTimeout(resizeTimer);
		  resizeTimer = setTimeout(function()
		  {
		    updateChart(false);
		  }, 100);
		}
</script>
</body>
</html>